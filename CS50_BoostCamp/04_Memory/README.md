# 메모리
## 16진수 (Hexadecimal)
### 표현방법
**그림_0 ~ f**
**그림_ff**

## 메모리 주소
- '%p\n' : 포인터는 컴퓨터 메모리의 주소를 가리키는 것임
- '&' 연산자 : "~의 주소"를 의미하는 연산자
- '*' 연산자 : "그 주소로 가줘"라는 의미  
**그림 1_address_2**  
**그림 1_address_3**

## 포인터
**그림 2_address**
- '*'로 쓰이며 *p 안에 &n의 주소를 저장
- int *p = p 앞의 *는 이 변수가 포인터라는 의미, int는 이 포인터가 int 타입의 변수를 가르킨다는 의미
- 포인터 p의 값 : 변수 n의 주소를 출력
- 포인터 *p의 값 : p가 가르키는 변수의 값, 즉 변수 n의 값 출력

## 문자열
- C에서 문자열은 여러 문자의 묶음을 추상화한 것
- 지금까지 쓴 string 자료형은 cs50.h에서 제공하는 기능
- 실제로는 type *char string으로 쓰였으며, string s = "EMMA"일 때 s는 "EMMA"라는 문자를 가르키는 포인터임
    - s의 주소는 "E" 첫 문자에 속하고 컴퓨터가 알아서 널 종단 문자까지 읽음
- 실제 코드 작성시 char *s = "EMMA"로 사용

- 위의 논리로 보았을 때 실제로 서로 다른 변수에 EMMA를 입력할 시 메모리에 저장하는 주소가 다르기 때문에 저장된 문자열을 같아도 둘을 비교 하면 다른 것으로 뜸 (주소값 불일치)

### 문자열 복사
**그림5_copy.c**
**그림5_copy_2.c**
**그림5_copy_3.c**

## 메모리 할당과 해제
- 할당 : malloc
- 해제 : free( )
- 메모리 누수로 인한 현상은 valgrind라는 프로그램으로 확인 가능 (free로 해제해야함)
- 버퍼 오버플로우는 할당하지 않은 인덱스에 값을 저장시 발생
**그림**

## 메모리 교환, 스택, 힙
**그림(메모리)**
1. 머신코드 : 맨 위에는 clang이 컴파일한 0과 1의 값이 들어감
2. 전역변수
3. 힙 : 메모리를 할당 받을 수 있는 커다란 영역
    -  malloc을 호출하면 메모리가 이 영역에서 나옴
4. 스택 : 함수의 지역 변수는 메모리 제일 아래 영역에 놓임
    - main의 한 개 이상의 인자나 지역변수

## 파일 쓰기
### 입력
- scanf( )
    - 현재까지 get_string, get_int를 썼지만 scanf를 통해 형식지정자에 해당하는 값을 입력받아 함수를 저장
    - scanf에는 주소로 입력해줌 (char *는 주소이기 때문에 & 필요 없음)
    - scanf 함수의 변수가 실제로 스택 영역 안에 s가 저장된 주소로 찾아가 사용자가 입력한 값을 저장하도록 하기 위함

**NULL 그림**
- char *는 메모리 영역의 주소를 저장할 수 있는 변수
- NULL은 메모리 공간이 할당되지 않았다는 뜻

### 쓰기
- fopen 함수를 이용해 FILE 자료형 불러올 수 있음
**그림**
- fopen함수의 첫번째 인자는 파일의 이름, 두번째 인자는 모드
    - r은 읽기, w는 쓰기, a는 덧붙이기